---
title: '队列&栈'
date: 2019-06-25 11:39:49
tags: 数据结构
---

# 介绍

1. 了解FIFO和LIFO处理顺序的原理
2. 实现这两个数据结构
3. 熟悉内置的队列和栈结构
4. 解决基本的队列相关问题，尤其是BFS
5. 解决基本的栈相关问题
6. 理解当你使用 DFS 和其他递归算法来解决问题时，系统栈是如何帮助你的。

## 队列：先入先出的数据结构

1. 理解FIFO和队列的定义；
2. 能够自己实现队列；
3. 熟悉内置队列结构；
4. 使用队列来解决简单的问题；

![队列](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/14/screen-shot-2018-05-03-at-151021.png)

在FIFO数据结构中，将`首先处理添加到队列中的第一个元素`。
插入（insert）操作也称为入队（enqueue），新元素始终被添加在`队列的末尾`。删除（delete）操作也被称为出队（dequeue）。你只能移除第一个元素。

## 队列-实现

为了实现队列，我们可以使用动态数组和指向队列头部的索引。

如上所述，队列应支持两种操作：入队和出队。入队会向队列追加一个新元素，而出队会删除第一个元素。 所以我们需要一个索引来指出起点。

```java
class MYQueue {
    private List<Integer> data;
    private int p_start;
    public MyQueue() {
        data = new ArrayList<Integer>();
        p_start = 0;
    }

    public boolean enQueue(int x) {
        data.add(x);
        return true;
    }

    public boolean deQueue() {
        if (isEmpty() == true) {
            return false;
        }
        p_start++;
        return true;
    }

    public int Front() {
        return data.get(p_start);
    }

    public boolean isEmpty() {
        return p_start >= data.size();
    }
}
```

## 循环队列

此前，简单但是低效的队列实现。
更有效的方法是使用循环队列。使用`固定大小的数组`和`两个指针`来指示起始位置和结束位置。目的是`重用`之前`被浪费的存储`。

循环队列的实现：

1. 初始化queue，设置queue的`maxSize`，`head`和`tail`节点
2. 入队`enqueue`：检查元素个数是否是maxSize-1；
   - Yes，返回Queue满了
   - No，在tail的位置上增加新元素，并增加`tail`节点
3. 出队`dequeu`：检查队列中个数是否为0
   - Yes，返回Queue是空
   - No，减少`head`节点
4. 找`size`：
   - tail >= head， `size = (tail - head) + 1`
   - head > tail, `size = maxSize - (head - tail) + 1`

```java
class MyCircularQueue {
    int data[];
    int p_start;
    int p_end;

    /** Initialize your data structure here. Set the size of the queue to be k. */
    public MyCircularQueue(int k) {
        data = new int[k];
        p_start = -1;
        p_end = -1;
    }

    /** Insert an element into the circular queue. Return true if the operation is successful. */
    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        } else {
            if (p_start == -1) {
                p_start = 0;
            }
            p_end = (p_end + 1) % (data.length);
            data[p_end] = value;
            return true;
        }
    }

    /** Delete an element from the circular queue. Return true if the operation is successful. */
    public boolean deQueue() {
        int y;
        if (isEmpty()) {
            return false;
        } else {
            y = data[p_start];
            if (p_start == p_end) {
                p_start = -1;
                p_end = -1;
            } else {
                p_start = (p_start + 1) % data.length;
            }
            return true;
        }
    }
    
    /** Get the front item from the queue. */
    public int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[p_start];
    }
    
    /** Get the last item from the queue. */
    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[p_end];
    }
    
    /** Checks whether the circular queue is empty or not. */
    public boolean isEmpty() {
        if (p_start == -1) {
            return true;
        }
        return false;
    }
    
    /** Checks whether the circular queue is full or not. */
    public boolean isFull() {
        if(p_start  == 0 && p_end == data.length - 1) {
            return true;
        }
        if (p_start == p_end + 1) {
            return true;
        }
        return false;
    }
}

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */
```

## 队列和BFS

广度优先搜索（BFS）是一个常见应用是找出从根结点到目标结点的最短路径。

1. 结点的处理顺序
第一轮中，处理根结点；第二轮中，处理根结点旁边的结点；在第三轮中，处理距根结点两步的结点；等等
与树的层序遍历类似，越是接近根结点的结点将越早地遍历。
如果在第k轮中将结点`X`添加到队列中，则根节点与`X`之间的最短路径的长度恰好是`k`。也就是说，第一次找到目标结点时，你已经处于最短路径中。
2. 队列的入队和出队顺序是什么？
首先将根节点排入队列。在每一轮中，逐个处理已经在队列中的结点，并将所有邻居添加到队列中。新添加的结点`不会`立即遍历，而是在下一轮中处理。
结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出

## 广度优先搜索-模板

```java
/**
 * 返回根结点到目标结点的最短路径
 */ 
int BFS(Node root, Node target) {
    Queue<Node> queue; //保存所有待处理的所有结点
    int step = 0; //从根结点到当前结点的步数
    //初始化
    add root to queue;
    while (queue is not empty) {
        step = step + 1;
        //遍历在队列总的结点
        int size = queue.size();
        for (int i = 0; i < size; ++i) {
            Node cur = this first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                add next to queue;
            }
            remove the first node from queue;
        }
    }
    return -1;

}

```

1. 每一轮中，队列中的节点是`等待处理的结点`。
2. 在每个更外一层的`while`循环之后，我们距离根结点更远一步。遍历`step`指示从根结点到正在访问的当前结点的距离。

```java
int BFS(Node root, Node target) {
    Queue<Node> queue;
    Set<Node> used; //保存所有已经使用过的结点
    int step = 0;
    //初始化
    add root to queue;
    add root to used;
    //BFS
    while (queue is not empty) {
        step = step + 1;
        int size = queue.size();
        for (int i = 0； i < size; ++i) {
            Node cur = this first node in queue;
            return step if cur is target;
            for (Node next : this neighbors of cur) {
                if (next is not in used) {
                    add next to queue;
                    add next to used;
                }
            }
            remove the first node from queue;
        }
    }
    return -1;

}
```
