<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/learnleetcode/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/learnleetcode/lib/pace/pace-theme-minimal.min.css?v=1.0.2">















  
  
  <link rel="stylesheet" href="/learnleetcode/lib/fancybox/source/jquery.fancybox.css">







<link rel="stylesheet" href="/learnleetcode/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/learnleetcode/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/learnleetcode/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/learnleetcode/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/learnleetcode/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/learnleetcode/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/learnleetcode/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="特别欢喜你">
<meta property="og:type" content="website">
<meta property="og:title" content="阿拉蕾的笔记本">
<meta property="og:url" content="https://littlefoxtail.github.io/page/3/index.html">
<meta property="og:site_name" content="阿拉蕾的笔记本">
<meta property="og:description" content="特别欢喜你">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="阿拉蕾的笔记本">
<meta name="twitter:description" content="特别欢喜你">





  
  
  <link rel="canonical" href="https://littlefoxtail.github.io/page/3/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>阿拉蕾的笔记本</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/learnleetcode/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">阿拉蕾的笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">你在我的心上说来最情长</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/learnleetcode/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/learnleetcode/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/learnleetcode/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/learnleetcode/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/learnleetcode/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/littlefoxtail" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://littlefoxtail.github.io/learnleetcode/2018/04/05/search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="特别欢喜你">
      <meta itemprop="image" content="/learnleetcode/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿拉蕾的笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/learnleetcode/2018/04/05/search/" class="post-title-link" itemprop="url">二分查找</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2018-04-05 23:57:00" itemprop="dateCreated datePublished" datetime="2018-04-05T23:57:00+08:00">2018-04-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-06-28 10:41:25" itemprop="dateModified" datetime="2019-06-28T10:41:25+08:00">2019-06-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/learnleetcode/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分搜索也称折半搜索、对数搜索，是一个在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束，如果某一特定元素大于或者小鱼中间元素，则在数组大于或者小鱼中间元素的那一半中查找。这种搜索算法每一次比较都使搜索范围缩小一半。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>折半搜索每次把搜索区域减少一半，时间复杂度O(logn)<br>空间复杂度：虽以递归形式定义，但是尾递归，可改写为循环</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://littlefoxtail.github.io/learnleetcode/2018/04/05/sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="特别欢喜你">
      <meta itemprop="image" content="/learnleetcode/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿拉蕾的笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/learnleetcode/2018/04/05/sort/" class="post-title-link" itemprop="url">算法基础知识</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2018-04-05 23:57:00" itemprop="dateCreated datePublished" datetime="2018-04-05T23:57:00+08:00">2018-04-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-06-28 10:42:42" itemprop="dateModified" datetime="2019-06-28T10:42:42+08:00">2019-06-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/learnleetcode/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>时间复杂度：分析关键字的比较次数和记录的移动次数。<br>它定量描述了该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度用大O符号表述，不包括这个函数的低阶项<br>和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。  </p>
<p>为了计算时间复杂度，我们通常会估计算法的操作单元数量，每个单元运行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多<br>相差一个常量系数。</p>
<p>相同大小的不同输入值仍可能造成算法的运行时间不同，因此我们通常使用算法最坏情况复杂度，记为<img src="https://latex.codecogs.com/gif.latex?T(n)" title="T(n)">，定义为任何大小的输入n所需的<br>最大运行时间。另一种较少使用的方法是平均情况复杂度，通常有特别指定才会使用。时间复杂度可以用函数<code>T(n)</code>的自然特性加以分类。<br>例如：T(n) = O(n)的算法被称作<em>线性时间算法</em>；而 <img src="https://latex.codecogs.com/gif.latex?T(n)&space;=&space;O(Mn)" title="T(n) = O(Mn)"> 和 <img src="https://latex.codecogs.com/gif.latex?Mn=&space;O(T(n))" title="Mn= O(T(n))"> ，其中 M ≥ n &gt; 1 的算法被称作指数时间算法。</p>
<p><a href="https://zh.wikipedia.org/wiki/时间复杂度" target="_blank" rel="noopener">时间复杂度</a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>复杂度类</th>
<th>运行时间(T(n))</th>
<th>运行时间举例</th>
<th>算法举例</th>
</tr>
</thead>
<tbody><tr>
<td>常数时间</td>
<td></td>
<td><img src="https://latex.codecogs.com/gif.latex?O(1)" title="O(1)"></td>
<td>10</td>
<td>判断一个二进制数的奇偶</td>
</tr>
<tr>
<td>迭代对数时间</td>
<td></td>
<td><img src="https://latex.codecogs.com/gif.latex?O(log^*n)" title="O(log^*n)"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>对数时间</td>
<td>DLOGTIME</td>
<td><img src="https://latex.codecogs.com/gif.latex?O(logn)" title="O(logn)"></td>
<td><img src="https://latex.codecogs.com/gif.latex?logn" title="logn">,<img src="https://latex.codecogs.com/gif.latex?logn^2" title="logn^2"></td>
<td>二分搜索</td>
</tr>
<tr>
<td>线性时间</td>
<td></td>
<td><img src="https://latex.codecogs.com/gif.latex?O(n)" title="O(n)"></td>
<td>n</td>
<td>无序数组的搜索</td>
</tr>
<tr>
<td>线性对数时间</td>
<td></td>
<td><img src="https://latex.codecogs.com/gif.latex?O(nlogn)" title="O(nlogn)"></td>
<td><img src="https://latex.codecogs.com/gif.latex?nlogn" title="nlogn">,<img src="https://latex.codecogs.com/gif.latex?logn!" title="logn!"></td>
<td>最快的比较排序</td>
</tr>
<tr>
<td>二次时间</td>
<td></td>
<td><img src="https://latex.codecogs.com/gif.latex?O(n^2)" title="O(n^2)"></td>
<td><img src="https://latex.codecogs.com/gif.latex?n^2" title="n^2"></td>
<td>冒泡排序、插入排序</td>
</tr>
<tr>
<td>三次时间</td>
<td></td>
<td><img src="https://latex.codecogs.com/gif.latex?O(n^3)" title="O(n^3)"></td>
<td><img src="https://latex.codecogs.com/gif.latex?n^3" title="n^3"></td>
<td>矩阵乘法的基本实现，计算部分相关性</td>
</tr>
<tr>
<td>阶乘时间</td>
<td></td>
<td><img src="https://latex.codecogs.com/gif.latex?O(n!)" title="O(n!)"></td>
<td><img src="https://latex.codecogs.com/gif.latex?n!" title="n!"></td>
<td>通过暴力搜索解决旅行推销员问题</td>
</tr>
<tr>
<td>——-</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>空间复杂度：分析排序算法中需要多少辅助内存</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>记做<img src="https://latex.codecogs.com/gif.latex?S(n)=O(f(n))" title="S(n)=O(f(n))">。比如直接插入排序空间复杂度<img src="https://latex.codecogs.com/gif.latex?O(1)" title="O(1)">。而一般递归算法就要有<img src="https://latex.codecogs.com/gif.latex?O(n)" title="O(n)">的空间复杂度，</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>因为每次递归都要存储返回信息。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<p>稳定性：若两个记录A和B的关键字相等，但是排序后AB的先后次序保持不变（稳定）</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">冒泡排序</a>（bubble sort）— O(<em>n</em>2)</li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">插入排序</a>（insertion sort）—O(<em>n</em>2)</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">鸡尾酒排序</a>（cocktail sort）—O(<em>n</em>2)</li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">桶排序</a>（bucket sort）—O(<em>n</em>)；需要O(<em>k</em>)额外空间</li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">计数排序</a>（counting sort）—O(<em>n</em>+<em>k</em>)；需要O(<em>n</em>+<em>k</em>)额外空间</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">归并排序</a>（merge sort）—O(<em>n</em> log <em>n</em>)；需要O(<em>n</em>)额外空间</li>
<li>原地<a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">归并排序</a>— O(<em>n</em> log2 <em>n</em>)如果使用最佳的现在版本</li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91" target="_blank" rel="noopener">二叉排序树</a>排序（binary tree sort）— O(<em>n</em> log <em>n</em>)期望时间；O(<em>n</em>2)最坏时间；需要O(<em>n</em>)额外空间</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%B8%BD%E5%B7%A2%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">鸽巢排序</a>（pigeonhole sort）—O(<em>n</em>+<em>k</em>)；需要O(<em>k</em>)额外空间</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">基数排序</a>（radix sort）—O(<em>n</em>·<em>k</em>)；需要O(<em>n</em>)额外空间</li>
<li><a href="https://zh.wikipedia.org/w/index.php?title=%E4%BE%8F%E5%84%92%E6%8E%92%E5%BA%8F&action=edit&redlink=1" target="_blank" rel="noopener">侏儒排序</a>（gnome sort）— O(<em>n</em>2)</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">图书馆排序</a>（library sort）— O(<em>n</em> log <em>n</em>)期望时间；O(<em>n</em>2)最坏时间；需要(1+ε)<em>n</em>额外空间</li>
<li><a href="https://zh.wikipedia.org/w/index.php?title=%E5%A1%8A%E6%8E%92%E5%BA%8F&action=edit&redlink=1" target="_blank" rel="noopener">块排序</a>（block sort）— O(<em>n</em> log <em>n</em>)</li>
</ul>
<h1 id="原地算法"><a href="#原地算法" class="headerlink" title="原地算法"></a>原地算法</h1><p>一个原地算法(in-place algorithm)是一种使用小的，固定数量的额外之空间来转换资料的算法。<br>当算法执行时，输入的资料通常会别要输出的部分覆盖掉。不是原地算法称为非原地(not-in-place)</p>
<h1 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h1><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>数组</td>
</tr>
<tr>
<td>时间复杂度</td>
<td><img src="https://latex.codecogs.com/gif.latex?O(n^2)" title="O(n^2)"></td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td><img src="https://latex.codecogs.com/gif.latex?O(n)" title="O(n)"></td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td><img src="https://latex.codecogs.com/gif.latex?O(n^2)" title="O(n^2)"></td>
</tr>
<tr>
<td>空间复杂度</td>
<td>总<img src="https://latex.codecogs.com/gif.latex?O(n)" title="O(n)">，需要辅助空间<img src="https://latex.codecogs.com/gif.latex?O(1)" title="O(1)"></td>
</tr>
</tbody></table>
<h2 id="1-1-性能分析"><a href="#1-1-性能分析" class="headerlink" title="1.1 性能分析"></a>1.1 性能分析</h2><p>时间复杂度<img src="https://latex.codecogs.com/gif.latex?O(n^2)" title="O(n^2)">,空间复杂度<img src="https://latex.codecogs.com/gif.latex?O(1)" title="O(1)"><br>排序时间与输入相关：输入的元素个数；元素已排序的程度。<br>最佳情况，输入数组是已经排好序的数组，运行时间是<code>n</code>的线性函数；最坏情况，输入数组是逆序，运行时间是<code>n</code>的二次函数</p>
<p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，<br>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h2 id="1-2-算法描述"><a href="#1-2-算法描述" class="headerlink" title="1.2 算法描述"></a>1.2 算法描述</h2><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<h1 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2.冒泡排序"></a>2.冒泡排序</h1><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>数组</td>
</tr>
<tr>
<td>最坏时间复杂度</td>
<td><img src="https://latex.codecogs.com/gif.latex?O(n^2)" title="O(n^2)"></td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td><img src="https://latex.codecogs.com/gif.latex?O(n)" title="O(n)"></td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td><img src="https://latex.codecogs.com/gif.latex?O(n^2)" title="O(n^2)"></td>
</tr>
<tr>
<td>空间复杂度</td>
<td>总共<img src="https://latex.codecogs.com/gif.latex?O(n)" title="O(n)">，需要辅助空间<img src="https://latex.codecogs.com/gif.latex?O(1)" title="O(1)"></td>
</tr>
</tbody></table>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<p>冒泡排序对n个项目需要<img src="https://latex.codecogs.com/gif.latex?O(n^2)" title="O(n^2)">的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于少数<br>元素之外的数列排序是很没有效率的。</p>
<p>冒泡排序与插入排序拥有相等的运行时间，但是两种算法在需要交换的次数却很大地不同。在最好的情况下，冒泡排序需要<img src="https://latex.codecogs.com/gif.latex?O(n^2)" title="O(n^2)"><br>次交换，而插入排序只要最多<img src="https://latex.codecogs.com/gif.latex?O(n)" title="O(n)">交换。</p>
<p>冒泡排序算法的运作如下：<br>    1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>    2. 对每一对相邻元素作同样的工作，从开始到第一队到结尾的最后一对。这布做完后，最后的元素会是最大的数。<br>    3. 针对所有的元素重复以上的步骤，除了最后一个<br>    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<h1 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3.快速排序"></a>3.快速排序</h1><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>不定</td>
</tr>
<tr>
<td>最坏时间复杂度</td>
<td><img src="https://latex.codecogs.com/gif.latex?O(n^2)" title="O(n^2)"></td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td><img src="https://latex.codecogs.com/gif.latex?O(nlogn)" title="O(nlogn)"></td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td><img src="https://latex.codecogs.com/gif.latex?O(nlogn)" title="O(nlogn)"></td>
</tr>
<tr>
<td>空间复杂度</td>
<td>根据实现方式不同而不同</td>
</tr>
</tbody></table>
<p>在平均状况下，排序n个项目要<img src="https://latex.codecogs.com/gif.latex?O(nlogn)" title="O(nlogn)">次比较。在最坏状况下则需要<img src="https://latex.codecogs.com/gif.latex?O(n^2)" title="O(n^2)">,但这种状况并不常见。事实上，快速排序通常<br>明显比其他<img src="https://latex.codecogs.com/gif.latex?O(nlogn)" title="O(nlogn)">算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>快速排序使用分治法策略把一个序列(list)分为两个子序列(sub-lists)。<br>步骤：<br>    1. 从数列中挑出一个元素，称为“基准”(pivot)<br>    2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准大的摆在基准的后面。<br>    在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区(partition)操作。<br>    3. 递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">QS</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> PIndex = partition(array, start, end);</span><br><span class="line">        QS(array, start, PIndex -<span class="number">1</span>);</span><br><span class="line">        QS(array, PIndex+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dividerAndChange</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标准值</span></span><br><span class="line">    <span class="keyword">int</span> pivot = args[end];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> PIndex = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i].compareTo(pivot) &lt; =<span class="number">0</span>) &#123;</span><br><span class="line">            swap(array, i, PIndex);</span><br><span class="line">            PIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(array, PIndex, end);</span><br><span class="line">    <span class="keyword">return</span> PIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[fromIndex];</span><br><span class="line">    array[fromIndex] = array[toIndex];</span><br><span class="line">    array[toIndex] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>数组</td>
</tr>
<tr>
<td>时间复杂度</td>
<td><img src="https://latex.codecogs.com/gif.latex?O(nlogn)" title="O(nlogn)"></td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td><img src="https://latex.codecogs.com/gif.latex?O(nlogn)" title="O(nlogn)"></td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td><img src="https://latex.codecogs.com/gif.latex?O(nlogn)" title="O(nlogn)"></td>
</tr>
<tr>
<td>空间复杂度</td>
<td>总的<img src="https://latex.codecogs.com/gif.latex?O(n)" title="O(n)">,辅助<img src="https://latex.codecogs.com/gif.latex?O(1)" title="O(1)"></td>
</tr>
</tbody></table>
<p>堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，<br>并同时满足堆积的性质，即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<h2 id="堆节点的访问"><a href="#堆节点的访问" class="headerlink" title="堆节点的访问"></a>堆节点的访问</h2><p>通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：</p>
<ul>
<li>父节点i的左子节点在位置(1*i+1);</li>
<li>父节点i的右子节点在位置(2*i+2);</li>
<li>子节点i的父节点在位置floor((i-1)/2); # floor功能，即取不大于x的最大整数</li>
</ul>
<h2 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h2><p>在堆得数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作：</p>
<ul>
<li>最大堆调整(Max_Heaplfy)：将堆得末端子节点作调整，使得子节点永远小于父节点。</li>
<li>创建最大堆(Build_Max_Heap):将堆所有数据重新排序。</li>
<li>堆排序(HeapSort)：移除位在第一个数据的根节点，并做最大堆调整的递归运算。</li>
</ul>
<h1 id="归并操作"><a href="#归并操作" class="headerlink" title="归并操作"></a>归并操作</h1><p>归并操作(merge)，也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p>
<h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><pre><code>1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列所剩下的所有元素直接复制到合并序列尾</code></pre><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>原来如下(假设序列共有n个元素)：<br>    1. 将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素<br>    2. 将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素<br>    3. 重复步骤2，直到所有元素排序完毕</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://littlefoxtail.github.io/learnleetcode/2017/11/20/dataStructure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="特别欢喜你">
      <meta itemprop="image" content="/learnleetcode/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿拉蕾的笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/learnleetcode/2017/11/20/dataStructure/" class="post-title-link" itemprop="url">数据结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2017-11-20 14:31:08" itemprop="dateCreated datePublished" datetime="2017-11-20T14:31:08+08:00">2017-11-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-06-28 11:03:26" itemprop="dateModified" datetime="2019-06-28T11:03:26+08:00">2019-06-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/learnleetcode/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>是计算机中存储、组织数据的方式<br>数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>最基本、最简单的一种数据结构，一个线性表是n个具有相同特性的数据元素的有限序列。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>线性表主要由顺序表示或链式表示</p>
<h3 id="Array（数组）"><a href="#Array（数组）" class="headerlink" title="Array（数组）"></a>Array（数组）</h3><p>一种基本类型，其可以通过下标获取到对应位置的数据。<br>数组在内存中是一段连续的存储单元，每个数据依次放在每个单元中：</p>
<ul>
<li>创建一个数组，必须声明其长度，这意味着数组的大小是固定的，无法动态调整大小。</li>
<li>想要获取数组中第i个元素，其时间复杂度是O(1)，因为可以根据其地址直接找到它。同理修改也是。</li>
<li>因为地址是连续，想要在数组中插入一个元素是复杂的，因为从插入位置起，后边的所有元素都需要向后移动一位。同理删除也是，只是移动的方向向前。并且数组满时，就无法继续插入</li>
<li>因为数组要占据一整块内存，有可能产生许多碎片，也可能因为找不到合适的内存块，而导致存储失败</li>
</ul>
<h3 id="Linked-List（链表）"><a href="#Linked-List（链表）" class="headerlink" title="Linked List（链表）"></a>Linked List（链表）</h3><p>链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点指针。<br>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存，实现灵活的内存动态管理。<br>链表即是由节点(Node)组成的线性集合，每个节点可以利用指针指向其他节点。它是一种包含了多个节点的，能够用于表示序列的数据结构。</p>
<p>根据指针域的不同，链表分为单链表、双向链表、循环链表等</p>
<ul>
<li>声明一个链表时，不需要知道其长度，也不需要连续的内存块，所以其大小可以动态调整</li>
<li>链表的每个元素分为数据域和指针域，前者是实际存储的数据，后者则指向下一个元素的地址。和数组相比，每个元素需要占用内存更大了</li>
<li>要获取链表的第i个元素变得复杂，因为其地址存放在它上一个元素的指针域，所以只能从第一个元素起，进行i次操作</li>
<li>链表对查询表现也一般，需要遍历，时间复杂度为O(n)</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>丧失了随机访问的能力。不能像数组一样，给定一个索引直接拿出对应元素。底层机制中数组开辟的空间再内存中是连续分布的，可以直接寻找索引对应的偏移，直接计算出数据所存储的内存地址，直接用O(1)复杂度拿出。链表靠next连接，每个节点存储地址不同</p>
<p>数组与链表的选择：</p>
<ul>
<li>数组按照位置查找迅速，链表增删方便</li>
<li>数组是固定大小，链表可以随时扩充与缩减</li>
<li>链表每个元素占据内存略多与数组</li>
<li>数组和链表在查询方面表现都比较一般，耗时较长</li>
</ul>
<h4 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h4><ul>
<li><p>在链表头添加元素</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(e)</span><br><span class="line">newNode.next = head</span><br><span class="line">head = newNode</span><br></pre></td></tr></table></figure>
</li>
<li><p>在索引2的地方添加元素（只有索引1才知道索引2）</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node prevNode = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    prevNode = prevNode.next;</span><br><span class="line">&#125;</span><br><span class="line">Node newNode = <span class="keyword">new</span> Node()</span><br><span class="line">newNode.next = prevNode.next;</span><br><span class="line">prevNode.next = newNode;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取元素操作</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; x = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">    x = x.next;</span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除元素<br>  删除索引为2位置的元素</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到它之前的节点，next 设置 下一个</span></span><br><span class="line">prev.next = delNode.next</span><br><span class="line">delNode.next = <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>  想要改变链表</p>
</li>
</ul>
<h4 id="链表的应用"><a href="#链表的应用" class="headerlink" title="链表的应用"></a>链表的应用</h4><p>链表用来构建许多其他数据结构，如堆栈，队列和他们的派生<br>节点的数据域也可以成为另一个链表，通过这种手段，可以用列表来构建许多链性数据结构</p>
<ul>
<li><p>单向链表：<br>  链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表的下一个节点，而最后一个节点则指向一个空值</p>
<p>  一个单链表的节点被分为两个部分。第一个部分保存或者显示关于节点的信息，第二部分存储下一个节点的地址。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> d) &#123;</span><br><span class="line">        data = d;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双向链表：<br>  每个节点有两个连接：一个指向前一个节点(当此“连接”时，指向空值或者空列表)；而另一个指向下一个节点(当此“连接”时，指向空值或者空列表)</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node previous;<span class="comment">//前驱节点</span></span><br><span class="line">    <span class="keyword">private</span> Node next; <span class="comment">//后继节点</span></span><br><span class="line">    <span class="keyword">private</span> E e; <span class="comment">//泛型元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node previous, Node next, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.previous = previous;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.e = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环链表：<br>  首节点和末节点被连接在一起</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tail = head = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Node hd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            hd.next = hd;</span><br><span class="line">            tail = head = hd;</span><br><span class="line">            size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = hd;</span><br><span class="line">            hd.next = head;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTail</span><span class="params">(Node tl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            tl.next = tl;</span><br><span class="line">            tail = head = tl;</span><br><span class="line">            size ++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = tl;</span><br><span class="line">            tl.next = head;</span><br><span class="line">            tail = tl;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度：</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">增加/只对表头操作</td>
<td align="center">O(n)/O(1)</td>
</tr>
<tr>
<td align="center">删除/只对表头操作</td>
<td align="center">O(n)/O(1)</td>
</tr>
<tr>
<td align="center">修改</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">查询</td>
<td align="center">O(n)</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="Stack（栈）"><a href="#Stack（栈）" class="headerlink" title="Stack（栈）"></a>Stack（栈）</h3><p>栈也是一种线性结构；相比数组，栈对应的操作是数组的子集；只能从一端添加元素，也只能从一端取出元素（这一端称之为栈顶）<br>栈是一种后进先出的数据结构。Last In First Out</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">stack.size();</span><br></pre></td></tr></table></figure>

<p>JDK doc建议使用Deque代替Stack实现栈，因为Stack继承自Vecotor，需要synchronized，性能略低</p>
<p>比较Stack和Deque方法</p>
<table>
<thead>
<tr>
<th align="center">Stack方法</th>
<th align="center">等效的Deque方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">push(e)</td>
<td align="center">addFirst(e)</td>
</tr>
<tr>
<td align="center">pop()</td>
<td align="center">remoreFirst()</td>
</tr>
<tr>
<td align="center">peek()</td>
<td align="center">getFirst()</td>
</tr>
</tbody></table>
<ul>
<li>栈是元素的集合，其包含了两个基本操作：push操作可以用于将元素压入栈，pop操作可以将栈顶元素移除。</li>
<li>遵循后入先出(LIFO)原则</li>
<li>时间复杂度：<ul>
<li>索引:(O(n))</li>
<li>搜索:(O(n))</li>
<li>插入:(O(1))</li>
<li>移除:(O(1))</li>
</ul>
</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>队列是一种特殊的线性表，相比数组，队列对应的操作是数组的子集<br>它只允许在表的前端(front)进行删除操作，而在表的后端(rear)进行插入操作。（First In First Out）<br>进行插入操作的端称为对尾，进行删除操作的端称为对头。对列没有元素时，称为空队列</p>
<ul>
<li>队列是元素的集合，其包含了两个基本操作；enqueue操作可以用于将元素插入到队列中，而dequeeu操作则是将元素从队列中移除。</li>
<li>遵循先入先出原则(FIFO)。</li>
<li>时间复杂度：<ul>
<li>索引:(O(n))</li>
<li>搜索:(O(n))</li>
<li>插入:(O(1))</li>
<li>移除:(O(1))</li>
</ul>
</li>
</ul>
<ol>
<li><p>ConcurrentLinkedQueue<br> 是一个基于连接节点的无界线程安全队列<br> <code>add()</code>和<code>offer()</code>都是加入元素的方法(在ConcurrentLinkedQueue中，这两个方法没有任何区别)<br> <code>poll()</code>和<code>peek()</code>都是取头元素节点，区别在于前者会删除元素，后者不会</p>
</li>
<li><p>BlockingQueue</p>
<ul>
<li><p>ArrayBlockingQueue<br>基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，其内部没实现读写分离<br>也就意味着生产和消费不能完全并行，长度是需要定义的，可以指定先进先出或者先进后出，也叫有界队列。</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">抛出异常</th>
<th align="center">返回个特殊值</th>
<th align="center">阻塞到队列可用</th>
<th align="center">一定时间后退出</th>
<th align="center">操作方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">添加元素</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center">put(e)</td>
<td align="center">offer(e,time,unit)</td>
<td align="center">添加到对尾</td>
</tr>
<tr>
<td align="center">移除元素</td>
<td align="center">remove(e)</td>
<td align="center">poll(e)</td>
<td align="center">take()</td>
<td align="center">poll(e,time,unit)</td>
<td align="center">获取头元素并移除</td>
</tr>
<tr>
<td align="center">查询元素</td>
<td align="center">element(e)</td>
<td align="center">peek(e)</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">获取头元素不移除</td>
</tr>
</tbody></table>
</li>
<li><p>LinkedBlockingQueue<br>基于链表的阻塞队列，同ArrayBlockingQueue类似，其内部也是维护着一个数据缓冲池队列(链表)，LinkedBlockingQueue之所以能够高效的处理并发数据，是因为其内部实现采用分离锁(读写分离两个锁)，从而实现生产者和消费者操作的完全并行运行。它是一个无界队列</p>
</li>
<li><p>PriorityBlockingQueue<br>基于优先级的阻塞队列(优先级的判断通过构造函数传入的Compator对象来决定，也即是说传入队列的对象必须实现Comparable接口)，在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，他也是一个无界队列。add()并不进行排序操作，只有在取数据时才进行排序</p>
</li>
<li><p>DelayQueue<br>带有延迟时间的queue，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素<br>DelayQueue中的元素必须实现Delayed接口，DelayQueue是一个没有大小限制的队列，应用场景很多，比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等</p>
</li>
<li><p>SynchronousQueue<br>一种没有缓冲的队列，生产者产生的数据直接被消费者获取并消费<br>它模拟的功能类似于生活中一手交钱一手交货这种情形，像那种货到付款或者先付款后发货模型不适合使用SynchronousQueue。首先要知道SynchronousQueue没有容纳元素的能力，即它的isEmpty()方法总是返回true，但是给人的感觉却像是只能容纳一个元素</p>
</li>
</ul>
</li>
</ol>
<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><p>是一种无向图，其中任意两个顶点间存在唯一一条路径，或者说，只要没有回路的连通图就是树。</p>
<p><img src="/learnleetcode/2017/11/20/dataStructure/%E6%A0%91%E7%BB%93%E6%9E%84.jpeg" alt="树结构"></p>
<h3 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h3><p>二叉树是一种典型的树结构</p>
<p><img src="/learnleetcode/2017/11/20/dataStructure/binaryTree.png" alt="binaryTree"></p>
<ul>
<li><p>二叉树即是每个节点最多包含左子节点与右子节点这两个节点的树形数据结构，通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒</p>
<table>
<thead>
<tr>
<th align="center">完美二叉树</th>
<th align="center">Perfect Binary Tree</th>
<th align="center">除了叶子节点之外的每一个节点都有两个孩子，每一层(当然包含最后一层)都被完全填充</th>
<th align="center">A Perfect Binary Tree(PDT) is a tree with all leaf nodes at the same depth. All internal nodes have degree 2.</th>
<th align="center">每一层的度都为2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">完全二叉树</td>
<td align="center">Complete Binary Tree</td>
<td align="center">除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持左对齐</td>
<td align="center">A Complete Binary Tree(CBT) is binary three in which every level, excepte possibly the last, is completely filled, and all nodes are as far left as possible</td>
<td align="center">从根节点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子节点都靠左对齐</td>
</tr>
<tr>
<td align="center">完满二叉树</td>
<td align="center">Full/Strictly Binary Tree</td>
<td align="center">除了叶子结点之外的每一个结点都有两个孩子结点</td>
<td align="center">A Full Binary Tree(FBT) is a tree in which every node other than the leaves has two children</td>
<td align="center">所有非叶子节点的度都是2</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="存储二叉树"><a href="#存储二叉树" class="headerlink" title="存储二叉树"></a>存储二叉树</h3><p>二叉树和链表一样，动态数据结构</p>
<h4 id="顺序存储（数组存储）"><a href="#顺序存储（数组存储）" class="headerlink" title="顺序存储（数组存储）"></a>顺序存储（数组存储）</h4><p>二叉树可以用数组来存储，尤其是完美二叉树</p>
<h4 id="二叉链表存储"><a href="#二叉链表存储" class="headerlink" title="二叉链表存储"></a>二叉链表存储</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value; <span class="comment">//二叉树的值</span></span><br><span class="line">    <span class="keyword">private</span> Node leftChild; <span class="comment">//左孩子节点</span></span><br><span class="line">    <span class="keyword">private</span> Node rightChild; <span class="comment">//右孩子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>(<span class="keyword">int</span> value, Node leftChild, Node rightChild) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line">        <span class="keyword">this</span>.rightChild = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h3><ul>
<li>二叉搜索树(BST)是一种特殊的二叉树，其任何节点中的值都会大于或者等于其左子树中存储的值并且小于或者等于其右子树中存储的值。</li>
<li>时间复杂度：<ul>
<li>索引:O(log(n))</li>
<li>搜索:O(log(n))</li>
<li>插入:O(log(n))</li>
<li>删除:O(log(n))</li>
</ul>
</li>
</ul>
<p>如果是自定义对象想要使用二分搜索树，需要自定义好两个学生是如何进行比较的，想要加快搜索就要对于数据有一定的要求</p>
<h4 id="向二分搜索树添加元素"><a href="#向二分搜索树添加元素" class="headerlink" title="向二分搜索树添加元素"></a>向二分搜索树添加元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, T elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>, elem);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem.compareTo(node.data) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.left = add(node.left, elem);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right = add(node.right, elem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二分搜索搜的遍历"><a href="#二分搜索搜的遍历" class="headerlink" title="二分搜索搜的遍历"></a>二分搜索搜的遍历</h4><h5 id="什么是遍历"><a href="#什么是遍历" class="headerlink" title="什么是遍历"></a>什么是遍历</h5><p>遍历操作就是把所有节点都访问一遍；访问的原因和业务相关；</p>
<ul>
<li>深度优先遍历<br>前序、中序、后序遍历的非递归实现</li>
<li>广度优先遍历<br>层序遍历，一般采用非递归方式，使用队列实现</li>
</ul>
<h4 id="二分搜索树的前序遍历"><a href="#二分搜索树的前序遍历" class="headerlink" title="二分搜索树的前序遍历"></a>二分搜索树的前序遍历</h4><p>前序遍历顺序：是指先访问根，再访问左右</p>
<ul>
<li>非递归写法<br>  <img src="/learnleetcode/2017/11/20/dataStructure/puthg8eoh3.jpeg" alt="puthg8eoh3"><ol>
<li>初始根节点压入栈</li>
<li>出栈访问28</li>
<li>压入它的右孩子30，左孩16。</li>
<li>访问栈顶16</li>
<li>压入它的右左孩子</li>
</ol>
</li>
</ul>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历为：左根右</p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>左右根</p>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>意义：更快的找到问题的解，算法的实现在一棵虚拟的树上搜索，常用语算法设计中-最短路径</p>
<h4 id="二分搜索树的删除操作"><a href="#二分搜索树的删除操作" class="headerlink" title="二分搜索树的删除操作"></a>二分搜索树的删除操作</h4><h5 id="删除最小值、最大值"><a href="#删除最小值、最大值" class="headerlink" title="删除最小值、最大值"></a>删除最小值、最大值</h5><p>最小值位于整棵树最左下角，最大值位于整棵树的最右下角</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">findMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">findMax</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">      node = node.right;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><h5 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h5><p>广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法，简单来说，BFS从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。</p>
<p>实现方法：</p>
<ol>
<li><p>首先将根节点放入队列中</p>
</li>
<li><p>从队列中取出第一个节点，并检验它是否为目标</p>
<ul>
<li>如果找到目标，则结束搜索并回传结果</li>
<li>否则将它所有尚未检验过的直接子节点加入队列</li>
</ul>
</li>
<li><p>若队列为空，表示整张图都检查过了-即图中没有要搜索的目标。结束搜索并回传“找不到目标”</p>
</li>
<li><p>重复步骤2</p>
</li>
</ol>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><ul>
<li>字典树，又称基数或者前缀树，能够用于存储键为字符串的动态集合或者关联数组的搜索树。树中的节点并没有直接存储关键键值，而是该节点<br>在树中挂载位置决定了其关联键值。某个节点的所有子节点都拥有相同的前缀，整棵树的根节点则是空字符串。</li>
</ul>
<h2 id="Fenwick-Tree"><a href="#Fenwick-Tree" class="headerlink" title="Fenwick Tree"></a>Fenwick Tree</h2><ul>
<li>树状数组又称Binary Indexed Tree，其表现形式为树，不过本质上是以数组实现。数组中的下标代表着树种的顶点，每个顶点的父节点或者子节点<br>的下标能够通过位运算或得</li>
</ul>
<h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><ul>
<li><p>堆是一种特殊的满足某些特性的数据结构，整个堆中的所有的父子节点的键值都会满足相同的排序条件。堆更准确可以分为最大堆和最小堆，在最大堆中，<br>父节点的键值永远大小或者等于子节点的值，并且整个堆中的最大值存储与根节点；而最小堆中，父节点的键值永远小鱼或者等于其子节点的键值，并且<br>整个堆中的最小值存储与根节点。</p>
</li>
<li><p>时间复杂度：</p>
<ul>
<li><p>访问:O(log(n))</p>
</li>
<li><p>搜索:O(log(n))</p>
</li>
<li><p>插入:O(log(n))</p>
</li>
<li><p>移除:O(log(n))</p>
</li>
<li><p>移除最大值/最小值:O(1)</p>
<p><img src="/learnleetcode/2017/11/20/dataStructure/heap.png" alt="image"></p>
</li>
</ul>
</li>
</ul>
<h2 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h2><p>哈希表就是通过关键字来获取数据的一种数据结构，它通过把关键字映射为表中的位置来获取元素，这种映射主要使用Hash函数</p>
<p>Hash函数，实际上是建立起key与int值映射关系的函数。好比身份证号一样。<br>哈希表，就是一个数组，只是其元素不是按照数组的规则排列的。任何一个元素要放进哈希表，都必须先通过Hash函数获取一个int数值，这个数值经过处理后将作为它的存放位置，然后这个元素才能放进哈希表中。<br>哈希表完全继承了数组的优点，又显著的提高了查询的速度，又显著的提高了查询的速度，但有一个缺陷，这就是哈希碰撞</p>
<ul>
<li><p>哈希能够将任意长度的数据映射到固定长度的数据。哈希函数返回的即是哈希值，如果两个不同的键得到相同的哈希值，即将这种现象称为碰撞。</p>
</li>
<li><p>Hash Map:HashMap是一种能够建立起键与值之间关系的数据结构，HashMap能够使用哈希函数将键转化为桶或者槽中的下标，<br>从而优化对于目标值得搜索速度。</p>
<p>碰撞解决</p>
<ul>
<li>链地址法(Separate Chaining)：链地址法中，每个桶是相互独立的，包含了一系列-引的列表。搜索操作的时间复杂度即是搜索桶的时间与遍历列表的时间之和。</li>
<li>开地址法(Open Addressing)：在开地址法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个尚未被占用的地址。所谓开地址也是指某个元素的位置并不永远由哈希值决定。</li>
</ul>
</li>
</ul>
<h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>无论什么对象，都根据一个规则映射为一个int值。被转换的对象有无数种可能，但是int的值是有限的，这样必然会有不同的对象，映射到相同的int值，这就是所谓的哈希碰撞。发生碰撞之后，单纯的一维数组已经无法满足需求了</p>
<p>比较通用的方法，就是使用数组+链表组合的方式。当出现哈希碰撞时，在该位置的数据就通过链表的方式链接起来</p>
<p>JDK1.7及之前的版本，HashMap的存储结构和上图是一致的，JDK1.8之后还加入了红黑树进一步优化</p>
<p>哈希表是一种优化存储的思想，具体存储元素的依然是其他的数据结构。设计良好的哈希表，能同时兼备数组和链表的优点，它能在插入和查找时都具备良好的性能。然而设计不好的哈希表，有可能会出现较多的哈希碰撞，导致链表过长，从而哈希表会更像一个链表。还有当数据量很大时，为防止链表过长，就需要对数组进行扩容，这时就涉及到了数组的拷贝，其对性能的影响也很严重，所以需要提前对可能的情况有良好的预测，才能真正发挥哈希表的优势</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归（Recurision），指一种通过重复将问题分解成同类的子问题而解决问题的方法。递归方式可以被用于解决很多的计算机科学问题。</p>
<p>递归的强大之处在于它允许用户有限的语句描述无限的对象</p>
<p>所有的递归算法可以分为两步，第一步是求解基本问题（基线问题），第二步是核心，把原问题化未更小的问题，使用更小的问题构建原问题（递归问题）。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/learnleetcode/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/learnleetcode/">1</a><a class="page-number" href="/learnleetcode/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">博主</p>
              <div class="site-description motion-element" itemprop="description">特别欢喜你</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/learnleetcode/archives/">
                
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/learnleetcode/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  



  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/learnleetcode/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/learnleetcode/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/learnleetcode/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/learnleetcode/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/learnleetcode/lib/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script src="/learnleetcode/js/utils.js?v=7.1.2"></script>

  <script src="/learnleetcode/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/learnleetcode/js/affix.js?v=7.1.2"></script>

  <script src="/learnleetcode/js/schemes/pisces.js?v=7.1.2"></script>




  

  


  <script src="/learnleetcode/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
